---
created: 2024-09-24T13:04:43 (UTC -03:00)
tags: []
source: https://news.ycombinator.com/item?id=41621191
author: 
---

# If AI is helping people code better, why aren't products getting better? | Hacker News

> ## Excerpt
> If AI is helping people code a lot faster and better, why aren’t the products I regularly use getting way better?

---
<table><tbody><tr id="41621191"><td><span></span></td><td><center><a id="up_41621191" href="https://news.ycombinator.com/vote?id=41621191&amp;how=up&amp;auth=2e507eb6e6620c16a27ffb8217a5ff8c96a95e33&amp;goto=item%3Fid%3D41621191"></a></center></td><td><span><a href="https://news.ycombinator.com/item?id=41621191">If AI is helping people code better, why aren't products getting better?</a></span></td></tr><tr><td colspan="2"></td><td><span><span id="score_41621191">117 points</span> by <a href="https://news.ycombinator.com/user?id=thisismytest">thisismytest</a> <span title="2024-09-23T00:11:20.000000Z"><a href="https://news.ycombinator.com/item?id=41621191">1 day ago</a></span> <span id="unv_41621191"></span>| <a href="https://news.ycombinator.com/hide?id=41621191&amp;auth=2e507eb6e6620c16a27ffb8217a5ff8c96a95e33&amp;goto=item%3Fid%3D41621191">hide</a> | <a href="https://hn.algolia.com/?query=If%20AI%20is%20helping%20people%20code%20better%2C%20why%20aren%27t%20products%20getting%20better%3F&amp;type=story&amp;dateRange=all&amp;sort=byDate&amp;storyText=false&amp;prefix&amp;page=0">past</a> | <a href="https://news.ycombinator.com/fave?id=41621191&amp;auth=2e507eb6e6620c16a27ffb8217a5ff8c96a95e33">favorite</a> | <a href="https://news.ycombinator.com/item?id=41621191">151&nbsp;comments</a></span></td></tr><tr><td></td></tr><tr><td colspan="2"></td><td><div><p>If AI is helping people code a lot faster and better, why aren’t the products I regularly use getting way better?</p><p>Source: <a href="https://x.com/staysaasy/status/1837812645946126560" rel="nofollow">https://x.com/staysaasy/status/1837812645946126560</a></p></div></td></tr><tr><td></td></tr><tr><td colspan="2"></td><td><form action="comment" method="post"></form></td></tr></tbody></table>

<table><tbody><tr id="41637939"><td></td></tr><tr id="41626209"><td><table><tbody><tr><td indent="0"><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_41626209" href="https://news.ycombinator.com/vote?id=41626209&amp;how=up&amp;auth=75de991e6d3aad109def70c34d3a61b6e6c72e8e&amp;goto=item%3Fid%3D41621191#41626209"></a></center></td><td><br><div><p>There's a time delay between when an innovation is first adopted and when it has a real impact. You might spend anywhere from 2 months to 8 years [1] developing an application. I've seen numerous VC or bootstrapped companies that took 1.5 years to 2 years to launch, so I wouldn't expect AI to have had much an effect yet.</p><p>I'm also not sure about "better"; I find Copilot is a good wingman for writing things like shell scripts, CMD.EXE scripts, powershell scripts and python scripts that do simple things. Even there I find it confuses forward slashes and backslashes sometimes so I often have to do a little debugging. Copilot can help me figure out how to use obscure (to me) features of PostgreSQL in JooQ. It will also argue with me and take factually wrong positions such as telling me that there is no zero-argument version of Optional.orElseThrows() which there is.</p><p>[1] <a href="https://en.wikipedia.org/wiki/Concord_(video_game)" rel="nofollow">https://en.wikipedia.org/wiki/Concord_(video_game)</a></p></div></td></tr></tbody></table></td></tr><tr id="41626652"><td><table><tbody><tr><td indent="1"><img src="https://news.ycombinator.com/s.gif" height="1" width="40"></td><td><center><a id="up_41626652" href="https://news.ycombinator.com/vote?id=41626652&amp;how=up&amp;auth=7117b8759dbc9e6f2ca3cc7f487fd0276d739a29&amp;goto=item%3Fid%3D41621191#41626652"></a></center></td><td><br><div><p>ChatGPT came out in late 2022 so it has been almost 2 years since the "AI is going to change everything" wave started. Looking at myself and my coworkers I don't feel there has been an uptick in developer output in that time. We all have copilot licenses as well, I don't use mine but pair with people who do and it seems cool but not for much more beyond advanced autofill.</p><p>My big concern with all this stuff is it is pushing devs away from the uncomfortable part of coding. When you approach a new area of a codebase you just have to sit in discomfort and step through the code and experiment with it until your brain gains context. Sure you can tweak something on the surface to fix a bug, but to really gain full understanding of it can take days or even weeks.</p><p>Patience is one of a developers most important tools, whether its spending 30m uninterruptedly working to achieve "flow" state, or slowly stepping through a complex piece of code to see why it is failing. I worry AI is going to instill a rapid reward system that makes future devs goal just to rush to make it work. They won't have much interest in really gaining mastery over what they work on.</p></div></td></tr></tbody></table></td></tr><tr id="41630803"><td><table><tbody><tr><td indent="2"><img src="https://news.ycombinator.com/s.gif" height="1" width="80"></td><td><center><a id="up_41630803" href="https://news.ycombinator.com/vote?id=41630803&amp;how=up&amp;auth=0abf49900cb35a593f1df1ce768b6c705e53e55e&amp;goto=item%3Fid%3D41621191#41630803"></a></center></td><td><br><div><p>I haven't tried copilot yet. I have tried Claude 3.5, which is unexpectedly brilliant. I use it very regularly. But almost entirely useful for writing new code, not fixing old code.</p><p>I take your point with respect to understanding large existing codebases. AIs don't yet seem to deal well with strategic large-context thinking. But things are changing at such a furious pace, so that may change sometime much sooner than either of us expect. But you are right. At the present moment in time, AIs are not particularly good at that.</p><p>But overall, I am much more optimistic than you are. I think AIs will save us time, so that we can spend more time on issues of overall structure that make "spending months to understand a codebase" a thing of the very distant past. I have certainly worked on codebases that require "months to understand". But I would (perhaps naively) like to think that's a symptom of a disease that codebases shouldn't have, and that modern codebases usually don't have anymore (but sometimes do).</p></div></td></tr></tbody></table></td></tr><tr id="41631028"><td><table><tbody><tr><td indent="3"><img src="https://news.ycombinator.com/s.gif" height="1" width="120"></td><td><center><a id="up_41631028" href="https://news.ycombinator.com/vote?id=41631028&amp;how=up&amp;auth=cfeb31c7e17b0ef722b42a8ba040346669c935ff&amp;goto=item%3Fid%3D41621191#41631028"></a></center></td><td><br><div><p>Anecdata: Claude 3.5 sometimes nails on the first try something that I can't GPT4 (any version) to ever complete without errors. Most recently, an AHK 2.0 script concatenating some strings.</p></div></td></tr></tbody></table></td></tr><tr id="41626846"><td><table><tbody><tr><td indent="2"><img src="https://news.ycombinator.com/s.gif" height="1" width="80"></td><td><center><a id="up_41626846" href="https://news.ycombinator.com/vote?id=41626846&amp;how=up&amp;auth=d745260e95d8ede07556c23eb51c2784224d3dff&amp;goto=item%3Fid%3D41621191#41626846"></a></center></td><td><br><div><p>This resonates with me, but also I don’t want to presume too much about the value of the old ways of doing things. AI tools are going to drastically lower the bar of entry to programming, so it will be flooded with dilettantes, but people who can think will still apply their thinking in creative ways. It will be really interesting what happens as AI tools mature and a generation of AI-native developers figures out how to maximize them.</p></div></td></tr></tbody></table></td></tr><tr id="41629845"><td><table><tbody><tr><td indent="3"><img src="https://news.ycombinator.com/s.gif" height="1" width="120"></td><td><center><a id="up_41629845" href="https://news.ycombinator.com/vote?id=41629845&amp;how=up&amp;auth=cf0cb5ed86ec78131d404dfe0984e3650678295a&amp;goto=item%3Fid%3D41621191#41629845"></a></center></td><td><br><div><p>Maybe an unpopular opinion, but I believe that the bar of entry to programming has always been low. On Windows, some environment are just an exe away. And web dev can be done with Notepad. And there are many introductions books and video tutorials. What is hard for most people is formalism and detailing your idea as a sequence of steps, aka the programming mindset. Writing code was always easy (Before AI, we had copy-paste from the internet). But whether you're writing assembly or python, you still need the programming mindset and that's the first step. Then you need to learn software engineering (code hygiene, requirement gathering, tasks planning,...)</p></div></td></tr></tbody></table></td></tr><tr id="41627064"><td></td></tr><tr id="41627976"><td><table><tbody><tr><td indent="2"><img src="https://news.ycombinator.com/s.gif" height="1" width="80"></td><td><center><a id="up_41627976" href="https://news.ycombinator.com/vote?id=41627976&amp;how=up&amp;auth=fe67428dad4f10f5dce06adb82884ccfbe73fd6f&amp;goto=item%3Fid%3D41621191#41627976"></a></center></td><td><br><div><p>If you are afraid of that you should see the CMD.EXE scripts that Copilot writes. For that matter, copilot has a habit of making long bulleted lists so instead of just telling you to make a configuration change in settings it will also tell you how to do it with REGEDIT and the policy editor.</p></div></td></tr></tbody></table></td></tr><tr id="41629778"><td><table><tbody><tr><td indent="1"><img src="https://news.ycombinator.com/s.gif" height="1" width="40"></td><td><center><a id="up_41629778" href="https://news.ycombinator.com/vote?id=41629778&amp;how=up&amp;auth=41716439af1dc751fcd63f5f89ff5c3349bc0b2e&amp;goto=item%3Fid%3D41621191#41629778"></a></center></td><td><br><div><p>Of course this all depends on what you mean by "better", or for whom the product is better.</p><p>AI, like every technical advance in history, will be deemed "better" if fewer people make more money from it.</p><p>This has nothing to do with you, mister insignificant user...</p></div></td></tr></tbody></table></td></tr><tr id="41621287"><td><table><tbody><tr><td indent="0"><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_41621287" href="https://news.ycombinator.com/vote?id=41621287&amp;how=up&amp;auth=8795c8d0742ef6711233572dfca6646c3cf7cc28&amp;goto=item%3Fid%3D41621191#41621287"></a></center></td><td><br><div><p>Why would there be a correlation between how fast something is developed and its quality?</p><p>Assuming that AI is helping developers to write more code, it could mean:</p><p>* there are fewer developers</p><p>* developers are working less</p><p>* the efficiency gains are resulting in more products being created rather than existing products being improved</p><p>* AI isn't widely enough adopted or used to make enough of a difference</p><p>* the benefits are too recent to be measured</p></div></td></tr></tbody></table></td></tr><tr id="41626036"><td><table><tbody><tr><td indent="1"><img src="https://news.ycombinator.com/s.gif" height="1" width="40"></td><td><center><a id="up_41626036" href="https://news.ycombinator.com/vote?id=41626036&amp;how=up&amp;auth=d3d5b7f4b301af650e6ce5adcfb610b39f20f587&amp;goto=item%3Fid%3D41621191#41626036"></a></center></td><td><br><div><pre><code>    the efficiency gains are resulting in more 
    products being created rather than existing 
    products being improved
</code></pre><p>This has been perhaps the only constant in the history of this industry. As software tooling and hardware get better, we never really feel or see the gains because companies and individual developers are pressed to do <i>more.</i></p><p>If a tool makes my job 2x easier, then I'm simply expected to have 2x more output. Not 2x "better" output.</p></div></td></tr></tbody></table></td></tr><tr id="41637671"><td><table><tbody><tr><td indent="2"><img src="https://news.ycombinator.com/s.gif" height="1" width="80"></td><td><center><a id="up_41637671" href="https://news.ycombinator.com/vote?id=41637671&amp;how=up&amp;auth=a6b859fcea2d6bf0f41600d59f37bade428b4a6c&amp;goto=item%3Fid%3D41621191#41637671"></a></center></td><td><br><div><p>Because the quality of the product is not solely in engineering's hand. We build the products, and have a lot of impact on the microdecisions, but larger feature planning usually comes from product management, who ultimately should be the ones deciding what features to build to make the customer experience better</p></div></td></tr></tbody></table></td></tr><tr id="41626229"><td><table><tbody><tr><td indent="2"><img src="https://news.ycombinator.com/s.gif" height="1" width="80"></td><td><center><a id="up_41626229" href="https://news.ycombinator.com/vote?id=41626229&amp;how=up&amp;auth=21115b3909c70b27f25bc3c316515f3e247fcf16&amp;goto=item%3Fid%3D41621191#41626229"></a></center></td><td><br><div><p>100%. You can also see this with Moore's law. Hardware gains were converted to developer productivity gains.</p><p>Software is easier than ever to write, but now the average AAA video game is 100+ GB and most popular software is browser-based.</p></div></td></tr></tbody></table></td></tr><tr id="41621534"><td><table><tbody><tr><td indent="1"><img src="https://news.ycombinator.com/s.gif" height="1" width="40"></td><td><center><a id="up_41621534" href="https://news.ycombinator.com/vote?id=41621534&amp;how=up&amp;auth=249b6368f242d45a9341abb42dfe542ee2a101f6&amp;goto=item%3Fid%3D41621191#41621534"></a></center></td><td><br><div><p>&gt; <i>Why would there be a correlation between how fast something is developed and its quality?</i></p><p>I've found that for all but the smallest and tightest of teams, there definitely is a correlation... an inverse correlation.</p></div></td></tr></tbody></table></td></tr><tr id="41627693"><td><table><tbody><tr><td indent="2"><img src="https://news.ycombinator.com/s.gif" height="1" width="80"></td><td><center><a id="up_41627693" href="https://news.ycombinator.com/vote?id=41627693&amp;how=up&amp;auth=c4b3e939e833824c22dc5d9d2ec519b576f2e15c&amp;goto=item%3Fid%3D41621191#41627693"></a></center></td><td><br><div><p>The highest quality product is finished first, yeah.</p><p>Often the difference is between finishing within an order of magnitude of the predicted time versus not finishing at all. But the highest quality product is almost always finished first.</p><p>There are exceptions, and AFAIK, those are all for very small projects. In my experience, high-quality takes about a week to be paid back. So if you have something smaller that you'll throw away after a use, you may want to cut corners.</p></div></td></tr></tbody></table></td></tr><tr id="41622928"><td><table><tbody><tr><td indent="1"><img src="https://news.ycombinator.com/s.gif" height="1" width="40"></td><td><center><a id="up_41622928" href="https://news.ycombinator.com/vote?id=41622928&amp;how=up&amp;auth=f634996a4f5188dc4be7f464a2f0d716c7418c61&amp;goto=item%3Fid%3D41621191#41622928"></a></center></td><td><br><div><p>I can think of several ways in which faster development could lead to better quality. Let's say you have a fixed time to come up with a solution to a problem. If you are able to come up with one candidate and evaluate it in that time, you have to live with what you get. If you do two candidates, you can select the one that is better.</p><p>Another aspect of quality is "polish". A team that can get a UI in front of QA twice in a development cycle instead of only once will benefit from more fault-finding.</p></div></td></tr></tbody></table></td></tr><tr id="41625875"><td><table><tbody><tr><td indent="2"><img src="https://news.ycombinator.com/s.gif" height="1" width="80"></td><td><center><a id="up_41625875" href="https://news.ycombinator.com/vote?id=41625875&amp;how=up&amp;auth=2a2591b0bea7f4bf3ca08a7bcd3434df7900e38f&amp;goto=item%3Fid%3D41621191#41625875"></a></center></td><td><br><div><p>Parkinson's law tells us that work expands so as to fill the time available for its completion.</p><p>I think the more likely outcome would either be it still taking the same time to deliver, with extra fluff in the middle, or the time simply shrinks. One thing is still evaluated and shipped, but slight faster.</p></div></td></tr></tbody></table></td></tr><tr id="41621363"><td><table><tbody><tr><td indent="1"><img src="https://news.ycombinator.com/s.gif" height="1" width="40"></td><td><center><a id="up_41621363" href="https://news.ycombinator.com/vote?id=41621363&amp;how=up&amp;auth=3ceae5f81ff125fc82056679d25074e0d5e6d47f&amp;goto=item%3Fid%3D41621191#41621363"></a></center></td><td><br><div><p>I am leaning towards fewer developers. There is a crunch in the job market and companies are finding rate of progress as being similar before, so don't feel inclined to hire more</p></div></td></tr></tbody></table></td></tr><tr id="41621442"><td><table><tbody><tr><td indent="2"><img src="https://news.ycombinator.com/s.gif" height="1" width="80"></td><td><center><a id="up_41621442" href="https://news.ycombinator.com/vote?id=41621442&amp;how=up&amp;auth=17e431749b8457c448f311ea7a1459374b69f45a&amp;goto=item%3Fid%3D41621191#41621442"></a></center></td><td><br><div><p>Most companies I know are turning out less features, they are just more tuned features towards what they believe will provide value and less "moon shots".</p></div></td></tr></tbody></table></td></tr><tr id="41623829"><td><table><tbody><tr><td indent="3"><img src="https://news.ycombinator.com/s.gif" height="1" width="120"></td><td><center><a id="up_41623829" href="https://news.ycombinator.com/vote?id=41623829&amp;how=up&amp;auth=cfaef88f5ee17f6da65e9e88c662f24ad17c4a90&amp;goto=item%3Fid%3D41621191#41623829"></a></center></td><td><br><div><p>To me it looks like "usability" never gets on top of that value list. Yet the seminars and courses and LinkedIn posts season everything with that word.</p></div></td></tr></tbody></table></td></tr><tr id="41621356"><td><table><tbody><tr><td indent="1"><img src="https://news.ycombinator.com/s.gif" height="1" width="40"></td><td><center><a id="up_41621356" href="https://news.ycombinator.com/vote?id=41621356&amp;how=up&amp;auth=8587c47fa67c00d082385b283be7393009c3bf77&amp;goto=item%3Fid%3D41621191#41621356"></a></center></td><td><br><div><p>Is there any evidence for any of those hypotheses? More apps in app stores? Mass layoffs? How could the "benefits be too recent to be measured" if everyone is arguing that they are already 10x more productive?</p><p>If you accept that premise the only conclusion left is that it has made developer's work much less but their bosses haven't noticed yet.</p><p>But you would still expect that <i>some</i> people are working for themselves and continue to work the same amount of hours so should be producing 10 apps a year instead of 1. Are there any examples of that?</p></div></td></tr></tbody></table></td></tr><tr id="41622815"><td><table><tbody><tr><td indent="2"><img src="https://news.ycombinator.com/s.gif" height="1" width="80"></td><td><center><a id="up_41622815" href="https://news.ycombinator.com/vote?id=41622815&amp;how=up&amp;auth=6f16cc906cf039790f12c84131022a97c8ed1756&amp;goto=item%3Fid%3D41621191#41622815"></a></center></td><td><br><div><p>If "everyone is arguing that they are already 10x" since GPT4 18mo ago, why aren't they 100x with _o1 and 3.5 Sonnet? Maybe it's bs and they've been spending actual hours getting maybe 2x more productive for the last year. None of it has kicked in yet? It might continue to improve? Who knows.</p><p>Actual productivity takes time, and actual products take work. Talk is cheap, show me the code.</p></div></td></tr></tbody></table></td></tr><tr id="41625307"><td><table><tbody><tr><td indent="2"><img src="https://news.ycombinator.com/s.gif" height="1" width="80"></td><td><center><a id="up_41625307" href="https://news.ycombinator.com/vote?id=41625307&amp;how=up&amp;auth=14db05c010e41cac641a726df1f6fa253bc02e5a&amp;goto=item%3Fid%3D41621191#41625307"></a></center></td><td><br><div><p>Yes jobs cut will be secondary market first.</p><p>India have had massive layoffs in tech sector.</p><p>Europe and US will follow suit once companies layoff dead weight in outsourcing locations first.</p></div></td></tr></tbody></table></td></tr><tr id="41625346"><td><table><tbody><tr><td indent="1"><img src="https://news.ycombinator.com/s.gif" height="1" width="40"></td><td><center><a id="up_41625346" href="https://news.ycombinator.com/vote?id=41625346&amp;how=up&amp;auth=a7089851ce8e4d04f02eb18500afe63d05215e98&amp;goto=item%3Fid%3D41621191#41625346"></a></center></td><td><br><div><p>And does it matter? The broader economy is whats is killing me and everyone one else. Healthcare and education are luxuries i dump tons of money into providing healthcare and education for my kid. Healthcare for myself.</p></div></td></tr></tbody></table></td></tr><tr id="41626109"><td></td></tr><tr id="41626354"><td><table><tbody><tr><td indent="1"><img src="https://news.ycombinator.com/s.gif" height="1" width="40"></td><td><center><a id="up_41626354" href="https://news.ycombinator.com/vote?id=41626354&amp;how=up&amp;auth=55ad84d4a2aedd588811efd6ae46ea2f127b11d5&amp;goto=item%3Fid%3D41621191#41626354"></a></center></td><td><br><div><p>Last junior dev I spoke to, taught themselves React, spent months building a very polished portfolio, got hired to work with a new "language" they hadn't heard of called "Angular". This dev was taking up the job because it paid well, they otherwise had a disdain for tech.</p><p>If these are the people who are coming into the industry, LLMs will not help them. There is no desire to learn or understand or dig even remotely beneath the surface.</p></div></td></tr></tbody></table></td></tr><tr id="41626572"><td><table><tbody><tr><td indent="2"><img src="https://news.ycombinator.com/s.gif" height="1" width="80"></td><td><center><a id="up_41626572" href="https://news.ycombinator.com/vote?id=41626572&amp;how=up&amp;auth=b5728544a9b92587f69063ec0155047e91fb6cdb&amp;goto=item%3Fid%3D41621191#41626572"></a></center></td><td><br><div><p>Ever since FORTRAN came on the scene, there have been tools that make disdainful, unskilled programmers more productive. I doubt this will ever change. It’s in the interest of mainstream employers to treat programmers as a fungible resource. There’s a much smaller risk to your business when you hire ten and get one or two good ones in the lot, than if you hire one good one and pay them triple. Things average out, and you’re not beholden to a few people who know their worth. As long as the pay is good enough to keep a couple of competent people around, you can rely on them to cover for the rest. Best of all, you never have to figure out which is which.</p></div></td></tr></tbody></table></td></tr><tr id="41627588"><td><table><tbody><tr><td indent="3"><img src="https://news.ycombinator.com/s.gif" height="1" width="120"></td><td><center><a id="up_41627588" href="https://news.ycombinator.com/vote?id=41627588&amp;how=up&amp;auth=25e5feb6cb1b6db06fe2b5ed767f5f29d5a11e93&amp;goto=item%3Fid%3D41621191#41627588"></a></center></td><td><br><div><p>You mean COBOL? FORTRAN wasn't really about lowest common competence.</p><p>Anyway, about this:</p><p>&gt; It’s in the interest of mainstream employers to treat programmers as a fungible resource.</p><p>It's in their interest to make programmers fungible. It's self-delusional to think they succeeded.</p></div></td></tr></tbody></table></td></tr><tr id="41628466"><td><table><tbody><tr><td indent="4"><img src="https://news.ycombinator.com/s.gif" height="1" width="160"></td><td><center><a id="up_41628466" href="https://news.ycombinator.com/vote?id=41628466&amp;how=up&amp;auth=b5c4a24044d6f3680a95bf88b1c876b6c6cd1f3e&amp;goto=item%3Fid%3D41621191#41628466"></a></center></td><td><br><div><p>No, I do mean FORTRAN. Massively lowered the bar. Not that COBOL didn’t, but it was in a different domain and slightly later as I understand it. Have you ever worked with properly old FORTRAN? Some of it is quite good, but some of it, well, it’s regrettable it was ever transferred off of paper tape.</p></div></td></tr></tbody></table></td></tr><tr id="41626462"><td><table><tbody><tr><td indent="2"><img src="https://news.ycombinator.com/s.gif" height="1" width="80"></td><td><center><a id="up_41626462" href="https://news.ycombinator.com/vote?id=41626462&amp;how=up&amp;auth=a582bffbda9c83bccfb3c1c52ff8d6c0d549cead&amp;goto=item%3Fid%3D41621191#41626462"></a></center></td><td><br><div><p>They’ll have to learn Angular for their new job, so “no desire to learn” seems harsh and unfair</p></div></td></tr></tbody></table></td></tr><tr id="41626600"><td><table><tbody><tr><td indent="2"><img src="https://news.ycombinator.com/s.gif" height="1" width="80"></td><td><center><a id="up_41626600" href="https://news.ycombinator.com/vote?id=41626600&amp;how=up&amp;auth=5984f11a6a895da52daaf47b224e91c2d5220aef&amp;goto=item%3Fid%3D41621191#41626600"></a></center></td><td><br><div><p>As someone who enjoys tech, I don't really fault or look down on people who get into tech for the pay like some in our field seem to do. In basically every other field on the planet that is high paying, people go into it for the money, not for some passion - so whats different about ours?</p><p>I don't really mind whether you have some innate desire to learn something, or if you're doing because its your job and your job pays you. As long as in the end you suck it up and do it.</p></div></td></tr></tbody></table></td></tr><tr id="41626952"><td><table><tbody><tr><td indent="3"><img src="https://news.ycombinator.com/s.gif" height="1" width="120"></td><td><center><a id="up_41626952" href="https://news.ycombinator.com/vote?id=41626952&amp;how=up&amp;auth=2d291a218edeba3ba9dcddbd7f17924466ba1185&amp;goto=item%3Fid%3D41621191#41626952"></a></center></td><td><br><div><p>I don't know that there's anything different about ours, but that's a shame.</p><p>The difference (broad-brushing here) between someone who is a dev because that's their passion and someone who is a dev for the pay is the quality of their work. As our industry matured and gathered more "in it for the money" types, the overall product quality has been declining.</p><p>I think that's a shame. Perhaps inevitable, but a shame nonetheless.</p></div></td></tr></tbody></table></td></tr><tr id="41626495"><td><table><tbody><tr><td indent="1"><img src="https://news.ycombinator.com/s.gif" height="1" width="40"></td><td><center><a id="up_41626495" href="https://news.ycombinator.com/vote?id=41626495&amp;how=up&amp;auth=0d8c42de057131ff7bce5bca68b3db4a2e8709dd&amp;goto=item%3Fid%3D41621191#41626495"></a></center></td><td><br><div><p>It, undeniably, makes prototyping incredibly fast. I’ve been forcing myself to use Cursor for the past month, and could create a fairly functional web app, given my skills aren’t front end dev. Very sweet for one off deterministic python scripts, figuring out the UI bugs, filling up boilerplate code and especially handy with languages/frameworks you’re not that familiar with.</p><p>Sure, we’re not at the “hook it up to prod codebase and ask it to make features from scratch” phase, but we didn’t have this 2 years ago either. But writing it off as completely useless? Nah.</p><p>I’m more of a process oriented person, who more or less cares about code quality. And as of now, it kinda sucks for it. However if your main goal is just the result, it’s delivering good stuff.</p></div></td></tr></tbody></table></td></tr><tr id="41629901"><td><table><tbody><tr><td indent="2"><img src="https://news.ycombinator.com/s.gif" height="1" width="80"></td><td><center><a id="up_41629901" href="https://news.ycombinator.com/vote?id=41629901&amp;how=up&amp;auth=ecf63f8b5ffe9345e4624594d9f2f4e443a025be&amp;goto=item%3Fid%3D41621191#41629901"></a></center></td><td><br><div><p>If your github-fu was good, you could get the same result with copy-pasting. But then you would need to worry about licenses. It's very convenient that Copilot and the like don't disclose the licenses of their training data.</p></div></td></tr></tbody></table></td></tr><tr id="41629155"><td><table><tbody><tr><td indent="2"><img src="https://news.ycombinator.com/s.gif" height="1" width="80"></td><td><center><a id="up_41629155" href="https://news.ycombinator.com/vote?id=41629155&amp;how=up&amp;auth=a630b665a1f41344bfbb833c45f35d9f2af5a7d1&amp;goto=item%3Fid%3D41621191#41629155"></a></center></td><td><br><div><p>I mean, I didn't say it was completely useless, just that it's not making code any better. There's definitely use cases for it. Rapid, throw-away prototyping may end up being one of them. (Though I am skeptical about that, given how often the prototype ends up being the finished product, but that's neither here nor there.)</p><p>If your main goal is the _short-term_ result, sure, it's delivering. In the longer term though, I still believe it to be dangerous.</p></div></td></tr></tbody></table></td></tr><tr id="41626925"><td><table><tbody><tr><td indent="0"><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_41626925" href="https://news.ycombinator.com/vote?id=41626925&amp;how=up&amp;auth=ed28272729be475a77c34009b36cd084737915ae&amp;goto=item%3Fid%3D41621191#41626925"></a></center></td><td><br><div><p>The simple answer is that product managers are not asking for quality. They're asking for cards/stories to be completed. "Quality" has been redefined as "meets requirements" or "passes UAT." Actual quality is just not in anyone's KPIs or OKRs.</p><p>That's why it's way easier for indie developers to deliver high-quality software—their incentives are directly aligned with the user.</p></div></td></tr></tbody></table></td></tr><tr id="41627089"><td><table><tbody><tr><td indent="1"><img src="https://news.ycombinator.com/s.gif" height="1" width="40"></td><td><center><a id="up_41627089" href="https://news.ycombinator.com/vote?id=41627089&amp;how=up&amp;auth=22960bb12e851e57991caf58567b6dbf880f6f00&amp;goto=item%3Fid%3D41621191#41627089"></a></center></td><td><br><div><p>Note that passes UAT could actually be nearly enough if UAT are properly written, your merge rules are strict enough and you do a minimum of complementary testing on release.</p><p>The issue is that the people writing the UAT generally have no incentive to write good UAT. They want to ship. They don't want to get code blocked because it doesn't meet requirements. Amusingly and to get back to the core of the discussion, AI is generally pretty good at helping write good UAT.</p></div></td></tr></tbody></table></td></tr><tr id="41621476"><td><table><tbody><tr><td indent="0"><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_41621476" href="https://news.ycombinator.com/vote?id=41621476&amp;how=up&amp;auth=1c553b6174d72ced837d0186b3e8cf0462215641&amp;goto=item%3Fid%3D41621191#41621476"></a></center></td><td><br><div><p>AI code assistants are amazing when you start from zero and just need a 80% working prototype. But once you start trying to refine the product from there, that's where the automation gets counterproductive. If you can exactly specify the problem, eg "Password input crashes when the password has an apostrophe", AI can probably fix it. But if the bug report comes in as "Password input randomly crashes", I will be very surprised if AI can figure out why and fix it. Where a human wrote the code, he or she may figure out why fairly quickly. Now, if you want a human who didnt write the code to understand the AI generated code, it may take a lot longer. In fact, in all likelihood, the AI assisted products are likely to be buggier and stay so longer, esp if companies start to think they can fire the senior devs and hire less skilled devs and fill the gap with AI. At some point, the pendulum will swing back, and companies will be chasing devs again.</p></div></td></tr></tbody></table></td></tr><tr id="41622497"><td><table><tbody><tr><td indent="1"><img src="https://news.ycombinator.com/s.gif" height="1" width="40"></td><td><center><a id="up_41622497" href="https://news.ycombinator.com/vote?id=41622497&amp;how=up&amp;auth=6c12b8216bcee323b53f8124298a1bca52ec69b2&amp;goto=item%3Fid%3D41621191#41622497"></a></center></td><td><br><div><p>It's certainly going to be fun seeing this all play out over the next 10 years.</p><p>In some ways it's like taking over a project written by someone else that's "80% done". You're locked into their design, get to analyze all that code 1 bug report at a time, get frustrated by obvious mistakes, confused (and mislead) when they relied on some clever side effect.</p><p>The quality of life in this maintainence mode depends enormously on the quality of the original coder. "Why did you choose this over that?" Is a common question I have for earlier devs. The AI answer is the least satisfying "it seemed like a good probability at the time".</p><p>IME writing the app from scratch to "done" is 10% of the lifecycle of the code. It's the other 90%, spanning over decades, where the quality (or lack thereof) reveals itself.</p><p>Personally I'm finding AI useful as a tool. Would I want to be the human fixing AI bugs? (From human bug reports which are pretty vague?) I'm not so sure about that.</p></div></td></tr></tbody></table></td></tr><tr id="41621239"><td><table><tbody><tr><td indent="0"><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_41621239" href="https://news.ycombinator.com/vote?id=41621239&amp;how=up&amp;auth=9c8b5f7b1a7dafa2cdc679b26a1d021a2a0d3862&amp;goto=item%3Fid%3D41621191#41621239"></a></center></td><td><br><div><p>My theory... Being able to code well or fast doesn't one to one translate to a good end user experience. The strength of your org's ability to determine good features and iterate on them from a product perspective is what matters, and that /can/ potentially happen faster if AI is enabling faster development, but it's not guaranteed.</p><p>Even if we had a magic box that results in perfect code coming out every time for a given feature description, that doesn't mean the feature itself is good or well thought out.</p></div></td></tr></tbody></table></td></tr><tr id="41626746"><td><table><tbody><tr><td indent="1"><img src="https://news.ycombinator.com/s.gif" height="1" width="40"></td><td><center><a id="up_41626746" href="https://news.ycombinator.com/vote?id=41626746&amp;how=up&amp;auth=2a2cb59a6a86a38351da4c8745b5e424e1838ee0&amp;goto=item%3Fid%3D41621191#41626746"></a></center></td><td><br><div><p>This. AI coding can almost turn an excellent product manager into a one man shop. We all know precious few exist.</p></div></td></tr></tbody></table></td></tr><tr id="41626484"><td><table><tbody><tr><td indent="0"><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_41626484" href="https://news.ycombinator.com/vote?id=41626484&amp;how=up&amp;auth=15a07bd6c04fb0bc4969ed4731717309b2c48c8e&amp;goto=item%3Fid%3D41621191#41626484"></a></center></td><td><br><div><p>Because Code ≠ Product. Code ∈ Product, among many other things.</p><p>I would go even further and say that that relationship between the two is weak, but also very peculiar: bad code <i>can</i> ruin a good product; but good code alone says very little, if anything at all, about the quality of a product.</p></div></td></tr></tbody></table></td></tr><tr id="41626640"><td><table><tbody><tr><td indent="1"><img src="https://news.ycombinator.com/s.gif" height="1" width="40"></td><td><center><a id="up_41626640" href="https://news.ycombinator.com/vote?id=41626640&amp;how=up&amp;auth=d740eab426e2b35c0bc9595daa1d8483f237452b&amp;goto=item%3Fid%3D41621191#41626640"></a></center></td><td><br><div><p>Another riff on this is that you won’t get better products, but more products. AI reduces the barrier of entry and you’ll have many products doing niche things (often for free!) instead of platforms capturing a lot of the incremental value.</p><p>It’s like mobile cameras, they reduced barrier of entry to photography, but you didn’t end up getting better photos necessarily. Instead you had more of them.</p></div></td></tr></tbody></table></td></tr><tr id="41635005"><td><table><tbody><tr><td indent="2"><img src="https://news.ycombinator.com/s.gif" height="1" width="80"></td><td><center><a id="up_41635005" href="https://news.ycombinator.com/vote?id=41635005&amp;how=up&amp;auth=e62e2dfd0430cd26c73c77af6545ddd15dc28764&amp;goto=item%3Fid%3D41621191#41635005"></a></center></td><td><br><div><p>&gt; It’s like mobile cameras, they reduced barrier of entry to photography, but you didn’t end up getting better photos necessarily. Instead you had more of them.</p><p>I like this idea, any new technology that empowers people simply increases volume, there's still an uncaptured element of strategy, design, and taste that doesn't improve with the tools themselves getting better.</p></div></td></tr></tbody></table></td></tr><tr id="41626507"><td></td></tr><tr id="41627106"><td><table><tbody><tr><td indent="1"><img src="https://news.ycombinator.com/s.gif" height="1" width="40"></td><td><center><a id="up_41627106" href="https://news.ycombinator.com/vote?id=41627106&amp;how=up&amp;auth=dde8154d6cba6f96b13ce7d54a4d89354ffebfe1&amp;goto=item%3Fid%3D41621191#41627106"></a></center></td><td><br><div><p>This is a great point. LLMs may flood an app with more features without making it better. At the end I do the day you still need to make something people love. AI may help you build that faster if you know what do build, but it’s not going to make a bad product great.</p></div></td></tr></tbody></table></td></tr><tr id="41621290"><td><table><tbody><tr><td indent="0"><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_41621290" href="https://news.ycombinator.com/vote?id=41621290&amp;how=up&amp;auth=20a3ec413c6b07fff3999c0297aef3b4d6643cd8&amp;goto=item%3Fid%3D41621191#41621290"></a></center></td><td><br><div><p>My experience with AI as a coding parter is yes, great at just doing boring things like take this list and give me an enum or add a form for this class etc .. but when I do anything remotly advanced it breaks apart, especially bad at dotnet where there are 25 years worth of history it source code from .. often it creates somthing that is long out of date, and jesus it tried to rewrite the same code ten times to solve a problem that was not supported by framework and could not be solved. So yea .. give it some years I guess. Still use it daily and I still need to fix Ai generated bugs ..</p></div></td></tr></tbody></table></td></tr><tr id="41621264"><td><table><tbody><tr><td indent="0"><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_41621264" href="https://news.ycombinator.com/vote?id=41621264&amp;how=up&amp;auth=ebacd30ec8bd09df021375f6ebcc7401743aeb2a&amp;goto=item%3Fid%3D41621191#41621264"></a></center></td><td><br><div><p>We're still very much in the early days.</p><p>Code AI tools today absolutely crush at creating proof of concept apps. You can test your idea and get market validation in days vs months.</p><p>They are getting better at medium/large codebases, but still have a ways to go before being super useful and it translating to a huge increase in productivity. Currently it's really good for helping with the menial tasks (creating docs, unit tests, understanding and onboarding) but not quite there yet when it comes to integrating gen ai code in large codebases, but it's only a matter of time.</p></div></td></tr></tbody></table></td></tr><tr id="41622283"><td><table><tbody><tr><td indent="1"><img src="https://news.ycombinator.com/s.gif" height="1" width="40"></td><td><center><a id="up_41622283" href="https://news.ycombinator.com/vote?id=41622283&amp;how=up&amp;auth=0aac3b9be34d0bcdd2a566015bdc4302718887f7&amp;goto=item%3Fid%3D41621191#41622283"></a></center></td><td><br><div><p>Not discounting your claim, but the fact that you work at a company (Sourcegraph) whose business is literally AI coding / coding assistants calls your objectivity <i>somewhat</i> into question.</p><p>I will agree that they're very useful for boilerplate tasks particularly around deployment (cloudformation, github actions, etc.)</p></div></td></tr></tbody></table></td></tr><tr id="41631594"><td><table><tbody><tr><td indent="2"><img src="https://news.ycombinator.com/s.gif" height="1" width="80"></td><td><center><a id="up_41631594" href="https://news.ycombinator.com/vote?id=41631594&amp;how=up&amp;auth=15ac2ac2263386c753233750922ff724a74102d2&amp;goto=item%3Fid%3D41621191#41631594"></a></center></td><td><br><div><p>Def don't take my word at face value. I'm just sharing my experience and knowledge, but the great thing about most of these tools is that many offer usable free tiers or very low-cost plans that don't require any sort of lock in. So try the tools yourself, for your use cases, and see if it's a fit or not.</p><p>Personally, I have seen a ton of change in the last 4-5 months, so if you haven't tried these tools recently, I encourage you to try them today and see what's possible.</p></div></td></tr></tbody></table></td></tr><tr id="41621344"><td></td></tr><tr id="41621370"><td><table><tbody><tr><td indent="2"><img src="https://news.ycombinator.com/s.gif" height="1" width="80"></td><td><center><a id="up_41621370" href="https://news.ycombinator.com/vote?id=41621370&amp;how=up&amp;auth=161d0833a13ae57c1f73d30d8febf353eeba55ae&amp;goto=item%3Fid%3D41621191#41621370"></a></center></td><td><br><div><p>Which one?</p><p>I run DevRel at Sourcegraph and our AI coding assistant, Cody, is used by tons of individuals, small business, and large enterprises. I get to talk to a ton of customers and see how their adoption of AI is going. And it's certainly increasing and developers are finding a ton of value.</p></div></td></tr></tbody></table></td></tr><tr id="41621499"><td><table><tbody><tr><td indent="3"><img src="https://news.ycombinator.com/s.gif" height="1" width="120"></td><td><center><a id="up_41621499" href="https://news.ycombinator.com/vote?id=41621499&amp;how=up&amp;auth=5bdb3f834f6403f59be43baa074afea81c16212a&amp;goto=item%3Fid%3D41621191#41621499"></a></center></td><td><br><div><p>Finding value in a product does make development go from months to days , which is the unsubstantiated claim. Even your customers can talk shit to sometimes in order to curry favour for a discount.</p></div></td></tr></tbody></table></td></tr><tr id="41621566"><td><table><tbody><tr><td indent="4"><img src="https://news.ycombinator.com/s.gif" height="1" width="160"></td><td><center><a id="up_41621566" href="https://news.ycombinator.com/vote?id=41621566&amp;how=up&amp;auth=93ee2aa0541da685a6e1c98596de8b73fe6ba896&amp;goto=item%3Fid%3D41621191#41621566"></a></center></td><td><br><div><p>Since gpt came out I have built tons of throwaway apps, plenty of specialized apps for side projects, and experimented with tons of ideas that I likely wouldn’t have if I didn’t have access to a tool to build it for me from just asking it to do it and explain what it did. Claude artifacts has been awesome for this. Cody when I actually want to build it out. I recommend trying it before you knock it.</p></div></td></tr></tbody></table></td></tr><tr id="41622753"><td><table><tbody><tr><td indent="5"><img src="https://news.ycombinator.com/s.gif" height="1" width="200"></td><td><center><a id="up_41622753" href="https://news.ycombinator.com/vote?id=41622753&amp;how=up&amp;auth=d3ab070cf3229b66711224cd899a1e8302a081e9&amp;goto=item%3Fid%3D41621191#41622753"></a></center></td><td><br><div><p>&gt; Since gpt came out I have built tons of throwaway apps, plenty of specialized apps for side projects, and experimented with tons of ideas that I likely wouldn’t have if I didn’t have access to a tool to build it for me from just asking it to do it and explain what it did.</p><p>GitHub Copilot, ChatGPT and Phind are all a bit like this for me - they both lower the barrier of entry and save me a lot of time for trivial algorithms and boilerplate code, in addition to helping me find things better than search engines sometimes do, especially when given a look at the code that I'm working with.</p><p>It might not be an order of magnitude difference in my case, but things that wouldn't have happened with the higher barrier of entry are now happening and that's quite the difference in of itself! I'm cautiously optimistic about LLMs and other forms of "AI". If nothing else, so far we basically have a more versatile form of IntelliSense, even if it's not always going to output correct code.</p><p>I wonder if some day it'll be feasible to feed in the entirety of a larger codebase and reason about it better than people who only know a part of it could.</p></div></td></tr></tbody></table></td></tr><tr id="41626961"><td><table><tbody><tr><td indent="6"><img src="https://news.ycombinator.com/s.gif" height="1" width="240"></td><td><center><a id="up_41626961" href="https://news.ycombinator.com/vote?id=41626961&amp;how=up&amp;auth=d5e38d342a967f171d4cb852feb85c48d0babe0f&amp;goto=item%3Fid%3D41621191#41626961"></a></center></td><td><br><div><p>&gt; If nothing else, so far we basically have a more versatile form of IntelliSense, even if it's not always going to output correct code.</p><p>That's the real issue for me. I remember learning programming and I either had not so good intelligence (Codeblocks, IDLE, Netbeans) or none at all (notepad++,...). This forces me to either follow the book attentively (and hunting down errata) or read the manual and getting explanations from forums or friends. When you're a beginner, uou need a good source of truth, not something that can be subtly wrong.</p></div></td></tr></tbody></table></td></tr><tr id="41625927"><td><table><tbody><tr><td indent="5"><img src="https://news.ycombinator.com/s.gif" height="1" width="200"></td><td><center><a id="up_41625927" href="https://news.ycombinator.com/vote?id=41625927&amp;how=up&amp;auth=09bac9aa50a0222fc2fd831230ce0e42d3d7d4c3&amp;goto=item%3Fid%3D41621191#41625927"></a></center></td><td><br><div><p>Cool, so we're re-visiting the 90s with RAD tools, just this time charged with AI.</p><p>Everything old is new again</p></div></td></tr></tbody></table></td></tr><tr id="41622838"><td><table><tbody><tr><td indent="5"><img src="https://news.ycombinator.com/s.gif" height="1" width="200"></td><td><center><a id="up_41622838" href="https://news.ycombinator.com/vote?id=41622838&amp;how=up&amp;auth=6e28fbb7387222c0d12230f4845f6c21c9d5e104&amp;goto=item%3Fid%3D41621191#41622838"></a></center></td><td><br><div><p>So you can give us a couple examples of apps you built with AI that are actually useful?</p></div></td></tr></tbody></table></td></tr><tr id="41626856"><td><table><tbody><tr><td indent="6"><img src="https://news.ycombinator.com/s.gif" height="1" width="240"></td><td><center><a id="up_41626856" href="https://news.ycombinator.com/vote?id=41626856&amp;how=up&amp;auth=40fd7e4c64b1cfa9ecf514632ee51e4adfd04cbb&amp;goto=item%3Fid%3D41621191#41626856"></a></center></td><td><br><div><p>Many services that power <a href="https://videotap.com/" rel="nofollow">https://videotap.com/</a> have recently been rewritten with the help of AI.</p><p>Recently I used Cody to rebuild the entire video processing pipeline and made it much more efficient and scalable, and I actually learned a ton about ffmpeg by pair programming with the AI. Now I'm building additional features into this app, mostly w/ just iterative prompting or chat-oriented programming to replace 3rd party services that are still in this pipeline and it's been a blast.</p><p>I've also used AI tools to really brush up on frameworks, like Laravel, that I haven't touched in a while, and it's been a great experience. Also started building a game w/ Godot and found AI super helpful there in walking me step by step. So for me it's been great.</p></div></td></tr></tbody></table></td></tr><tr id="41625656"><td><table><tbody><tr><td indent="6"><img src="https://news.ycombinator.com/s.gif" height="1" width="240"></td><td><center><a id="up_41625656" href="https://news.ycombinator.com/vote?id=41625656&amp;how=up&amp;auth=a3bbfc342bb6b3de30359ec204730cc96fd08e1b&amp;goto=item%3Fid%3D41621191#41625656"></a></center></td><td><br><div><p><i>Since gpt came out I have built tons of throwaway apps,</i></p><p>Throw away apps are the easiest to make. No scaling, no bug fixing, no long term maintenance considerations, no consequences for poor architecture, no need to consider data models, you just write some shit. Bravo.</p></div></td></tr></tbody></table></td></tr><tr id="41621352"><td><table><tbody><tr><td indent="1"><img src="https://news.ycombinator.com/s.gif" height="1" width="40"></td><td><center><a id="up_41621352" href="https://news.ycombinator.com/vote?id=41621352&amp;how=up&amp;auth=f94bf97849059ca42e638c722b3d2ce86019bcd7&amp;goto=item%3Fid%3D41621191#41621352"></a></center></td><td><br><div><p>&gt; They are getting better at medium/large codebases</p><p>If we are strictly speaking about the cutting-edge models like OpenAI's o1, their context is getting <i>smaller</i>, not larger.</p></div></td></tr></tbody></table></td></tr><tr id="41621385"><td><table><tbody><tr><td indent="2"><img src="https://news.ycombinator.com/s.gif" height="1" width="80"></td><td><center><a id="up_41621385" href="https://news.ycombinator.com/vote?id=41621385&amp;how=up&amp;auth=58aa831081a7438b982d5bf6d398d6eada85733e&amp;goto=item%3Fid%3D41621191#41621385"></a></center></td><td><br><div><p>I believe o1's context window will increase over time as well. It's a new model that takes a different approach compared to other ones, so testing it with less context seems logical and expanding the context window as it's quality is validated.</p><p>Even in a large code-base, you don't have to have the full context of every single file for every single question, can usually get away with half a dozen files, it's figuring out which ones to provide to the LLM to get the best response.</p></div></td></tr></tbody></table></td></tr><tr id="41621316"><td><table><tbody><tr><td indent="0"><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_41621316" href="https://news.ycombinator.com/vote?id=41621316&amp;how=up&amp;auth=c2e23061220443fdb3e65ef9c078f4db85cf6b88&amp;goto=item%3Fid%3D41621191#41621316"></a></center></td><td><br><div><p>All of the products you are using today were likely created before ChatGPT was released. For those products, you are not going to see any visible improvements because many of them will suffer from poor implementation due to lack of adequate knowledge of code/frameworks. Most software best practices are learned after the software is created and release. The code is probably very spaghetti and hard to maintain. Refactoring is still hard for AI, but writing from scratch is much easier with AI. For the software that is currently out, bugs will be fixed faster, and features might be added sooner.</p><p>The real explosion of great software will happen in 3-5 years. AI is huge for the beginning of projects. You know _what_ you want the app to do but you don't know _how_. That's where AI adds huge value. People are now starting new projects with AI help, and they are building foundations of codebases that will be much more maintainable and sustainable as development continues compared to the current suite of software products we interact with today.</p></div></td></tr></tbody></table></td></tr><tr id="41621345"><td><table><tbody><tr><td indent="1"><img src="https://news.ycombinator.com/s.gif" height="1" width="40"></td><td><center><a id="up_41621345" href="https://news.ycombinator.com/vote?id=41621345&amp;how=up&amp;auth=a1805491cea95eba19f22a9fc00b6645f4602d66&amp;goto=item%3Fid%3D41621191#41621345"></a></center></td><td><br><div><p>&gt; You know _what_ you want the app to do but you don't know _how_. That's where AI adds huge value. People are now starting new projects with AI help, and they are building foundations of codebases that will be much more maintainable and sustainable</p><p>I'm not following. How are these codebases going to be more maintainable and sustainable if the developers are committing code they don't even understand?</p></div></td></tr></tbody></table></td></tr><tr id="41621381"><td><table><tbody><tr><td indent="2"><img src="https://news.ycombinator.com/s.gif" height="1" width="80"></td><td><center><a id="up_41621381" href="https://news.ycombinator.com/vote?id=41621381&amp;how=up&amp;auth=94abb64ebe6b5d0496829c2add5ebbf82ff8a7ab&amp;goto=item%3Fid%3D41621191#41621381"></a></center></td><td><br><div><p>I think you misinterpret the 'don't know how' part. LLM's are fantastic for boilerplate (which is a big part of getting things started). From there, I might not know the right incantation for (say) handling a button click, but it's not too hard to validate that an LLM-generated handler a) works, b) looks sensible, and c) fits reasonably in the codebase. In fact, most of my use of LLMs for coding is about generating snippets of functionality, which go into a codebase that I'm maintaining the shape of... which helps maintainability.</p><p>You can also generate tests more efficiently, meaning you can get better test coverage cheaper. This leads to better maintainability as well, as you know more quickly when you've broken things with a change.</p></div></td></tr></tbody></table></td></tr><tr id="41622572"><td><table><tbody><tr><td indent="3"><img src="https://news.ycombinator.com/s.gif" height="1" width="120"></td><td><center><a id="up_41622572" href="https://news.ycombinator.com/vote?id=41622572&amp;how=up&amp;auth=b474786b0279210dc8bbcf2cfe2dce17f44447fb&amp;goto=item%3Fid%3D41621191#41622572"></a></center></td><td><br><div><p>Yeah precisely. In my case I’ve been building a Django rest app over the last few years. I started off writing way too much of my own code rather than using plugins I had no idea existed. After finally getting ahold of ChatGPT I was able to expand my knowledge of Django tenfold, and was able to rewrite the app from the ground up using proven libraries and design decisions.</p></div></td></tr></tbody></table></td></tr><tr id="41629932"><td></td></tr><tr id="41621825"><td><table><tbody><tr><td indent="0"><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_41621825" href="https://news.ycombinator.com/vote?id=41621825&amp;how=up&amp;auth=65f5bd86d4015402d0c6edf7af2af80497e06a02&amp;goto=item%3Fid%3D41621191#41621825"></a></center></td><td><br><div><p>"If AI is helping people code better, why aren't products getting better?"</p><p>Because it's not helping them code better. It might be faster, but the quality in my experience is worse. Then the user is trying to verify or troubleshoot code they didn't write.</p><p>The bigger issue is garbage in, garbage out at the requirements level. The business hardly ever documents their business system before turning it into a technical system. How can we create a system to meet requirements that nobody knows and didn't have a chance to really think about while writing the code?</p></div></td></tr></tbody></table></td></tr><tr id="41626072"><td><table><tbody><tr><td indent="0"><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_41626072" href="https://news.ycombinator.com/vote?id=41626072&amp;how=up&amp;auth=d78002276e1d5f3556aa7f71f3cfb2467560e6fa&amp;goto=item%3Fid%3D41621191#41626072"></a></center></td><td><br><div><p>bad developers emitting more code has never led to anything good</p><p>unless you're being paid to clean up the mess</p><p>it's like outsourcing on steroids</p></div></td></tr></tbody></table></td></tr><tr id="41621322"><td><table><tbody><tr><td indent="0"><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_41621322" href="https://news.ycombinator.com/vote?id=41621322&amp;how=up&amp;auth=a32a5a36c0aadf7e829356dc37c2f3d58cb47448&amp;goto=item%3Fid%3D41621191#41621322"></a></center></td><td><br><div><p>AI only helps those who are below-average to become (barely) average --- and that average is dropping. Also, quantity is not quality.</p></div></td></tr></tbody></table></td></tr><tr id="41626165"><td><table><tbody><tr><td indent="1"><img src="https://news.ycombinator.com/s.gif" height="1" width="40"></td><td><center><a id="up_41626165" href="https://news.ycombinator.com/vote?id=41626165&amp;how=up&amp;auth=ca4ca4199e5e39ffdd3fd2d2844f46d9a0440b6d&amp;goto=item%3Fid%3D41621191#41626165"></a></center></td><td><br><div><p>*Nobody is above-average in everything*.</p><p>You can be above-average in your favourite programming language, but suck at the system or library that will be required in your next project.</p><p>AI will help you get up to speed.</p></div></td></tr></tbody></table></td></tr><tr id="41621453"><td><table><tbody><tr><td indent="0"><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_41621453" href="https://news.ycombinator.com/vote?id=41621453&amp;how=up&amp;auth=7a34040629d0423b52fd022d61e1733c814e4a5f&amp;goto=item%3Fid%3D41621191#41621453"></a></center></td><td><br><div><p>1. They probably are. I'm sure I would notice a 500% increase in the rate that products get better, but I'm also sure I wouldn't notice 10%, which is much more realistic (but imo it's probably still less.)</p><p>2. Productivity gains don't go directly to products getting better. Individual developers may choose to realize some gains by spending more time with their family. Of course the company will claw that back but it takes time. And when they do, some of the gains may instead be realized by higher profit margins rather than better products and it will take time for consumers try to claw that back using their market choices.</p><p>3. Companies have lots of moving parts and a speed they're used to going; it will take time to adjust if one part goes a little faster.</p><p>4. LLM-assistants help a lot with getting up to speed in a new field or making stuff from scratch, and a lot less for a skilled team who already knows all the product code and surrounding tools. So "products you use regularly" benefit the least.</p></div></td></tr></tbody></table></td></tr><tr id="41621270"><td><table><tbody><tr><td indent="0"><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_41621270" href="https://news.ycombinator.com/vote?id=41621270&amp;how=up&amp;auth=27147d1f49dc8a26033e368962151c5a419632f5&amp;goto=item%3Fid%3D41621191#41621270"></a></center></td><td><br><div><p>Some possibilities:</p><p>1. The products you use are not developed by people using LLMs.</p><p>2. The products you use may be using LLMs in development, but only recently so you'll see a delay before any improvement.</p><p>3. The products you use are using it, and maybe it's helping with quality, but not anywhere that users care about or notice.</p><p>4. The products you use are using it, and it's not helping with quality, just churning out more code.</p></div></td></tr></tbody></table></td></tr><tr id="41626496"><td><table><tbody><tr><td indent="0"><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_41626496" href="https://news.ycombinator.com/vote?id=41626496&amp;how=up&amp;auth=00a71124e6e876105788eff55d94bf57101400f6&amp;goto=item%3Fid%3D41621191#41626496"></a></center></td><td><br><div><p>Programming with AI, so far, tries to specify something precise, algorithms, in a less precise language than what we have.</p><p>It's the difference between Euclid and modern notation, with AI programming being like Euclidean notation and current programming languages being the modern notation:</p><p>"if a first magnitude and a third are equal multiples of a second and a fourth, and a fifth and a sixth are equal multiples of the second and fourth, then the first magnitude and fifth, being added together, and the third and sixth, being added together, will also be equal multiples of the second and the fourth, respectively."</p><p>versus</p><p>a(x + y) = ax + by</p><p>If AI programming can find a better way to express the problems we're trying to solve, then yes, it could work. It would become a matter of "how well the compiler works". The current proposals which use natural language as the notation is not better than what we have.</p></div></td></tr></tbody></table></td></tr><tr id="41626588"><td><table><tbody><tr><td indent="1"><img src="https://news.ycombinator.com/s.gif" height="1" width="40"></td><td><center><a id="up_41626588" href="https://news.ycombinator.com/vote?id=41626588&amp;how=up&amp;auth=c6831cd591225a92f1672a6f848c9c171fcc08b1&amp;goto=item%3Fid%3D41621191#41626588"></a></center></td><td><br><div><p>The only problem with this is the fact that the 99%+ of issues with software products aren’t the fact that a parsimonious language was used and tightly coupled to the compiler</p><p>The vast majority of issues is missed edge cases between what the user wants and expects, and the design and function of the software</p><p>Higher productivity would in theory allow programmers more opportunities to address more issues</p><p>Programs don’t exist in a vacuum, users and other actors need to interact with them</p><p>Whether or not these LLMs result in increased productivity with the same or better quality is a more pertinent question</p></div></td></tr></tbody></table></td></tr><tr id="41627615"><td><table><tbody><tr><td indent="0"><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_41627615" href="https://news.ycombinator.com/vote?id=41627615&amp;how=up&amp;auth=1d6db1c95d2935a847ea3f45bbbd6b3b2e98753f&amp;goto=item%3Fid%3D41621191#41627615"></a></center></td><td><br><div><p>Because the quality of the code is at best very, very loosely related to the quality of the end product. I mean, what are many of the issues you see in poorly designed sites, apps, programs, etc?</p><p>Usually a mix of poor design choices and hostile design.</p><p>Neither of these directly correlate to the quality of the code, how quickly it was created, how many bugs it has, etc.</p><p>If everyone working in tech (or any sort of programming related project in general) was an expert level programmer with decades of experience, neither of these things would be noticeably better. They'd still create software that's miserable to use because of bad design, and we'd still have companies trying to scam the users by making basic functionality hard to use (see cookie notices, unsubscribe processes, etc).</p></div></td></tr></tbody></table></td></tr><tr id="41621245"><td><table><tbody><tr><td indent="0"><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_41621245" href="https://news.ycombinator.com/vote?id=41621245&amp;how=up&amp;auth=7d40496b7ce4ae80ec601b1cf1bfb696875d0996&amp;goto=item%3Fid%3D41621191#41621245"></a></center></td><td><br><div><p>Writing the same code 10% faster isn't necessarily going to make it better. Also the biggest improvements have been among novices, and the products you regularly use were predominantly written (or at least reviewed) by more experienced people.</p></div></td></tr></tbody></table></td></tr><tr id="41621279"><td><table><tbody><tr><td indent="0"><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_41621279" href="https://news.ycombinator.com/vote?id=41621279&amp;how=up&amp;auth=f92fb0ae84da67d70d7a9eeebcd040d5b41fe70e&amp;goto=item%3Fid%3D41621191#41621279"></a></center></td><td><br><div><p>I signed into Zapier yesterday for the first time in a while. You can seemingly run their entire UI right now via AI. I typed a simple idea into their AI box, and it created a multi-step "zap" for me that was more-or-less what I wanted.</p><p>So at least some software is getting better.</p></div></td></tr></tbody></table></td></tr><tr id="41621335"><td></td></tr><tr id="41626459"><td><table><tbody><tr><td indent="0"><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_41626459" href="https://news.ycombinator.com/vote?id=41626459&amp;how=up&amp;auth=2e760cf034151ead9ca6044c6a7aa11c604b55a4&amp;goto=item%3Fid%3D41621191#41626459"></a></center></td><td><br><div><p><i>Crucially</i>, products are more than "code". They are UX, they are support, they are maintainability, etc.</p><p>Also, in my experience, AI is helping people who don't know how to code to write code they don't understand and can't support. In my experience, the people who are already making products aren't getting much benefits from AI (not yet anyway).</p></div></td></tr></tbody></table></td></tr><tr id="41626741"><td><table><tbody><tr><td indent="0"><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_41626741" href="https://news.ycombinator.com/vote?id=41626741&amp;how=up&amp;auth=a390403ef86cfc53cfde5dce378c44d013a1d794&amp;goto=item%3Fid%3D41621191#41626741"></a></center></td><td><br><div><p>AI makes it easier to build a mediocre or just barely working product, hence rather a decline in quality is to be expected.</p></div></td></tr></tbody></table></td></tr><tr id="41622790"><td><table><tbody><tr><td indent="0"><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_41622790" href="https://news.ycombinator.com/vote?id=41622790&amp;how=up&amp;auth=b201bf497380b60bf361df68a537d0250e39ac1f&amp;goto=item%3Fid%3D41621191#41622790"></a></center></td><td><br><div><p>I think the primary reason is that datasets contain a lot more average/bad code than exceptional, and to add to that problem judging between those is possibly a subjective issue.</p><p>Developers using AI will get mostly average solutions faster but exceptional ones will be obviously rare. And, crucially if the idea itself is average or bad there isn't much an elegant coding solution will do for the idea.</p><p>I think this ultimately is the divide between the hype and reality of how AI will impact products. If you just give a product manager the keys to do all the coding as no code "prompt engineer", more than likely will lead to further enshitification of features in products with unmaintainable code bases. At the current state, understanding algorithms and thinking computationally is a requirement to improve a code base.</p><p>The hopes of having a "build me a $1 billion app" prompt capability, or "improve my shitty app" are too long horizon and subjective requests to bypass the hardships of product ideation and iteration to have the LLM deliver on the requests. It's not magic, it's probability. Averages are the end goal here, not excellence.</p><p>If we arrive at a point where LLMs translate general prompts into idealistic versions that are more like version 100 of the idea while still capturing the user's intent, then we will see these improvements. Otherwise it's copy pasta on steroids, and done mindlessly, will mostly lead to enshitification rather than improvements.</p></div></td></tr></tbody></table></td></tr><tr id="41621402"><td><table><tbody><tr><td indent="0"><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_41621402" href="https://news.ycombinator.com/vote?id=41621402&amp;how=up&amp;auth=54fa1492ec8a08501a71d906588243222fa58d67&amp;goto=item%3Fid%3D41621191#41621402"></a></center></td><td><br><div><p>Because like any tool, it can be used thoughtfully and it can be used carelessly.</p><p>There are use cases where LLMs help with coding (and they are growing as the things get better), but even if they could do as well as an experienced engineer at doing a first draft (which, debatable in any setting and falls off sharply once it's not a highly mainstream setting), a first draft is almost never a high-quality artifact.</p><p>They can also be used to get a sort of minimum viable diff that represents a liability to the codebase and those who maintain and depend on it, to do this with very little effort and therefore impose the negative externalities on someone else. Anecdotally this seems to be a distressingly common use case. I'm more than a little concerned that software quality is about to take an abrupt turn for the worse in aggregate.</p><p>More broadly, if you're anything like most people I know, the products you're using are getting better all the time... at making money for the companies that build them. Consumer Internet profits and/or valuations are at something like an all time high. All that lag and jank and spam and shit? That's not easy code to write or simple infrastructure to operate. That's full-metal-jacket monetization at great effort and expense.</p></div></td></tr></tbody></table></td></tr><tr id="41621445"><td><table><tbody><tr><td indent="0"><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_41621445" href="https://news.ycombinator.com/vote?id=41621445&amp;how=up&amp;auth=9fe3f30f6905569343c6414ab2097f8e88867cf9&amp;goto=item%3Fid%3D41621191#41621445"></a></center></td><td><br><div><p>I think of the current generation of AI coding tools as being like a developer with a little bit of experience in almost any tech stack and field of application.</p><p>If I’m investigating a new field or trying out a new language or library, relative to my own experience, then it’s quite common for an AI code generator to use idioms or libraries I hadn’t yet come across. That alone sometimes saves me a useful amount of time doing research.</p><p>However, it’s almost all breadth and very little depth. The quality of the generated code is rarely better than something a junior-to-mid-level developer might have written. It needs to be reviewed and corrected with similar diligence.</p><p>Similarly, the quality of a generated review of existing code or of generated supporting assets like test cases or documentation is often superficial and error-prone. I rarely find it an overall win to use current AI-based tools for these things instead of existing tools that can’t do as much but are consistent and reliable at what they do do.</p><p>So I wouldn’t necessarily expect current AI tools to help me code <i>better</i>, only sometimes a bit <i>faster</i>, and that mostly in new areas I’m exploring rather than areas where I’m doing professional work that is going to get shipped in the near future.</p></div></td></tr></tbody></table></td></tr><tr id="41621439"><td><table><tbody><tr><td indent="0"><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_41621439" href="https://news.ycombinator.com/vote?id=41621439&amp;how=up&amp;auth=bc6ae28d21d5105c307d53149f4eef36fb754d15&amp;goto=item%3Fid%3D41621191#41621439"></a></center></td><td><br><div><p>I have been messing around with a project using python on a raspberry pi. I know a little javascript but I'm no programmer and didn't know any python and hardly anything about linux before this. Chatgpt and Gemini have helped me a lot by writing code that included common libraries that I didn't know existed. Then I can modify it and tweak it to suit my needs.</p></div></td></tr></tbody></table></td></tr><tr id="41621519"><td><table><tbody><tr><td indent="0"><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_41621519" href="https://news.ycombinator.com/vote?id=41621519&amp;how=up&amp;auth=b271865a11aa0a3c8eef92b4af0e39127009bfee&amp;goto=item%3Fid%3D41621191#41621519"></a></center></td><td><br><div><p>An improvement in productivity does not necessarily imply improvements in quality. Where those extra engineering hours get spent is determined by management, and management are optimising for profit, which could mean optimising for quality but more likely means optimising for feature development.</p></div></td></tr></tbody></table></td></tr><tr id="41621251"><td><table><tbody><tr><td indent="0"><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_41621251" href="https://news.ycombinator.com/vote?id=41621251&amp;how=up&amp;auth=2dc3401aa871d7e96bffadf672922403fb3adcb6&amp;goto=item%3Fid%3D41621191#41621251"></a></center></td><td><br><div><p>This is a personal anecdote, and just one data point, but still. I work on websites for customers, and frequently I'll need to (for example) iterate through some spreadsheet data, or convert a big object of this format to some other format. These are tedious tasks that don't take a _huge_ amount of time, but instead of grinding on a particular function for 30 minutes, I have a workable thing I can tweak in five minutes. I'd say this helps me "code faster and better."</p><p>Does it make the end product better? Not really: I would have gotten there with a function written by me or some LLM. But like everything I've been asked to do my professional career, it allows me to do more with less. More dumb functions in less time.</p></div></td></tr></tbody></table></td></tr><tr id="41627645"><td><table><tbody><tr><td indent="0"><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_41627645" href="https://news.ycombinator.com/vote?id=41627645&amp;how=up&amp;auth=d974d8094a7709c8760f6a7e5b9da76add1c36ca&amp;goto=item%3Fid%3D41621191#41627645"></a></center></td><td><br><div><p>In my experience, AI is helping people code faster, not precisely better! It does not take long before we find the limitations of AI code-gen running you in circles.</p><p>As far as I know, most of us do research with AI to get ideas and find pros and cons but we are still the ones mostly driving the logic with AI filling in the function level blocks.</p></div></td></tr></tbody></table></td></tr><tr id="41626458"><td><table><tbody><tr><td indent="0"><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_41626458" href="https://news.ycombinator.com/vote?id=41626458&amp;how=up&amp;auth=f3b399887848b9c727367f55f73b2ad8d65328e9&amp;goto=item%3Fid%3D41621191#41626458"></a></center></td><td><br><div><p>Product development decisions are essentially completely independent of software development decisions. Product development is challenging in it's highly contextual, highly political, and essentially unique to every product.</p><p>It doesn't how effective software development is if you're not doing anything to improve the discovery and planning process.</p></div></td></tr></tbody></table></td></tr><tr id="41634514"><td></td></tr><tr id="41623284"><td><table><tbody><tr><td indent="0"><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_41623284" href="https://news.ycombinator.com/vote?id=41623284&amp;how=up&amp;auth=23ad785b14e40fa8eaedd5f812653f0c323823d3&amp;goto=item%3Fid%3D41621191#41623284"></a></center></td><td><br><div><p>AI tools, like what we develop at AI2sql <a href="https://ai2sql.io/" rel="nofollow">https://ai2sql.io/</a> , are helping speed up coding, but better code doesn’t always mean better products. Product development involves design, user experience, and business strategy, which AI doesn’t fully solve. Also, many AI-driven improvements happen behind the scenes, focusing on performance or stability, which users might not notice right away.</p></div></td></tr></tbody></table></td></tr><tr id="41626221"><td><table><tbody><tr><td indent="0"><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_41626221" href="https://news.ycombinator.com/vote?id=41626221&amp;how=up&amp;auth=a918cffdbe779b94de7e1f486a196fac5821b08b&amp;goto=item%3Fid%3D41621191#41626221"></a></center></td><td><br><div><p>I don't find them useful for coding much, but I do find them useful for searching through documentation and making suggestions. With Cursor, you can have it reference the docs for the library/framework you are using and then ask it questions about the docs. While this does not always work well, it can save a lot of time.</p></div></td></tr></tbody></table></td></tr><tr id="41626140"><td><table><tbody><tr><td indent="0"><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_41626140" href="https://news.ycombinator.com/vote?id=41626140&amp;how=up&amp;auth=f0c8ee2359527d1bfc5ff13b67eef68a67957771&amp;goto=item%3Fid%3D41621191#41626140"></a></center></td><td><br><div><p>I think it is helping them generate the same code faster, rather than generate code with different functionality.</p></div></td></tr></tbody></table></td></tr><tr id="41626630"><td><table><tbody><tr><td indent="0"><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_41626630" href="https://news.ycombinator.com/vote?id=41626630&amp;how=up&amp;auth=11526a4b0daf86d6f213a7c6e090b455be54ee13&amp;goto=item%3Fid%3D41621191#41626630"></a></center></td><td><br><div><p>At this point, I'd expect to see more new products, especially more web apps. Are there? Would be interesting to look at /show with that in mind. I know I'm creating things I couldn't without AI. I expect more people who aren't web devs to make web apps.</p></div></td></tr></tbody></table></td></tr><tr id="41626136"><td><table><tbody><tr><td indent="0"><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_41626136" href="https://news.ycombinator.com/vote?id=41626136&amp;how=up&amp;auth=773bd45bfd383a6819d9939527bcd07aa7815f9f&amp;goto=item%3Fid%3D41621191#41626136"></a></center></td><td><br><div><p>Because the quality / goodness of a product has little to do with the underlying code. Second, is it actually helping people code better? That's a claim that needs some paperwork to back it up, and first off all with a definition of "good".</p></div></td></tr></tbody></table></td></tr><tr id="41621398"><td><table><tbody><tr><td indent="0"><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_41621398" href="https://news.ycombinator.com/vote?id=41621398&amp;how=up&amp;auth=16c6c7445f722bd43f3f22d77268a0602bd31488&amp;goto=item%3Fid%3D41621191#41621398"></a></center></td><td><br><div><p>I don't think things are going to get "better". I think you'll see some homogeneity, where a lot of code will just converge at "average".</p></div></td></tr></tbody></table></td></tr><tr id="41626174"><td><table><tbody><tr><td indent="0"><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_41626174" href="https://news.ycombinator.com/vote?id=41626174&amp;how=up&amp;auth=aba4a8797f703eb6a1d9010ef7b3a00ba6652c76&amp;goto=item%3Fid%3D41621191#41626174"></a></center></td><td><br><div><p>Because coding assistants depend on the baselined code they are trained on for their suggestions?</p><p>I don't believe they offer creative solutions, just a faster way to refer. So it's still the responsibility of developers bring their creativity to the process.</p></div></td></tr></tbody></table></td></tr><tr id="41624516"><td><table><tbody><tr><td indent="0"><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_41624516" href="https://news.ycombinator.com/vote?id=41624516&amp;how=up&amp;auth=7f293aebc0308ba365c5a997b2d117f8f2a73eec&amp;goto=item%3Fid%3D41621191#41624516"></a></center></td><td><br><div><p>AI is helping more people code problems they might not be able to on their own or help people do it more quickly for a particular issue but don’t think that in general is making people better coders just like Google auto correct isn’t making people better spellers.</p></div></td></tr></tbody></table></td></tr><tr id="41626554"><td><table><tbody><tr><td indent="0"><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_41626554" href="https://news.ycombinator.com/vote?id=41626554&amp;how=up&amp;auth=f3e397b3f7a4b9325e81f05fe9693de45735ad9b&amp;goto=item%3Fid%3D41621191#41626554"></a></center></td><td><br><div><p>One could look back at history and ask how long it took for better coding tools to result in better software. This could go all the way back to programming languages, IDEs, frameworks, etc.</p></div></td></tr></tbody></table></td></tr><tr id="41621254"><td><table><tbody><tr><td indent="0"><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_41621254" href="https://news.ycombinator.com/vote?id=41621254&amp;how=up&amp;auth=975dbe50904350edfdb2e9fbc76fb85bc3112cf1&amp;goto=item%3Fid%3D41621191#41621254"></a></center></td><td><br><div><p>They don’t code better but they code faster.</p><p>I imagine for first pass prototypes, AI will greatly accelerate the process. But getting to the fine details and getting things done well will still take same amount of time.</p><p>AI-guided coding will help code up “good enough” implementations, which is great for research and testing ideas but not for production.</p></div></td></tr></tbody></table></td></tr><tr id="41626177"><td><table><tbody><tr><td indent="0"><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_41626177" href="https://news.ycombinator.com/vote?id=41626177&amp;how=up&amp;auth=a192e7cc2bfe70200c8056d6013ece5a6be4cbf1&amp;goto=item%3Fid%3D41621191#41626177"></a></center></td><td><br><div><p>The AI coding tools I see today help to make coders somewhat more efficient. That isn't something that's very visible in the software landscape as a whole.</p></div></td></tr></tbody></table></td></tr><tr id="41626210"><td></td></tr><tr id="41622758"><td><table><tbody><tr><td indent="0"><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_41622758" href="https://news.ycombinator.com/vote?id=41622758&amp;how=up&amp;auth=833d571ea50f848ed8969f6236b455e8753b3aad&amp;goto=item%3Fid%3D41621191#41622758"></a></center></td><td><br><div><p>My products are so much better because of AI. I can now build things I didn't even dream of building before. I am amazed that so many humans find it really hard to accept this new reality - computers can write better code than we do.</p></div></td></tr></tbody></table></td></tr><tr id="41623508"><td><table><tbody><tr><td indent="1"><img src="https://news.ycombinator.com/s.gif" height="1" width="40"></td><td><center><a id="up_41623508" href="https://news.ycombinator.com/vote?id=41623508&amp;how=up&amp;auth=05e61135ae7d0f987c5ea872f15ed6075b037f68&amp;goto=item%3Fid%3D41621191#41623508"></a></center></td><td><br><div><p>What products? Better how? How have you quantified this? Give us the numbers for these extraordinary claims.</p></div></td></tr></tbody></table></td></tr><tr id="41621369"><td><table><tbody><tr><td indent="0"><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_41621369" href="https://news.ycombinator.com/vote?id=41621369&amp;how=up&amp;auth=e2c16f570ad0bd8052532089a524d909c4196d6e&amp;goto=item%3Fid%3D41621191#41621369"></a></center></td><td><br><div><p>W/o a different incentive structure, nothing will get better from what it is now. And if there is a way to produce something cheaper and a functionally equivalent lower quality, that is what will happen.</p><p>For most part, it will be same quality or lower at a cheaper cost delivered faster.</p></div></td></tr></tbody></table></td></tr><tr id="41623946"><td><table><tbody><tr><td indent="0"><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_41623946" href="https://news.ycombinator.com/vote?id=41623946&amp;how=up&amp;auth=4326b5eea77d38a20d31fb936bf1c762bd0ea5ca&amp;goto=item%3Fid%3D41621191#41623946"></a></center></td><td><br><div><p>If pigs can fly, then why aren't there more bacon-scented aviation accidents caused by them getting sucked into jet engines?</p><p>Like, there's little reason to think that LLMs are helping people code better.</p></div></td></tr></tbody></table></td></tr><tr id="41621244"><td><table><tbody><tr><td indent="0"><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_41621244" href="https://news.ycombinator.com/vote?id=41621244&amp;how=up&amp;auth=add51c5806f0cea588d97036d7c09f6661212661&amp;goto=item%3Fid%3D41621191#41621244"></a></center></td><td><br><div><p>My guess would be that the hurdle in creating better products isn't in code completion.</p><p>User research, UX improvements, feature ideation and creation, etc, are all the same as they have always been. Getting the code out faster doesn't help if its in service of a bad feature.</p></div></td></tr></tbody></table></td></tr><tr id="41621272"><td></td></tr><tr id="41621353"><td><table><tbody><tr><td indent="0"><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_41621353" href="https://news.ycombinator.com/vote?id=41621353&amp;how=up&amp;auth=11bfe331e51788c0aff506a9e22b4cc510210578&amp;goto=item%3Fid%3D41621191#41621353"></a></center></td><td><br><div><p>Does anyone know if Github has any sort of public telemetry data (of if anyone from GH is around here somewhere)? There was a ChatGPT outage about a month ago and I'm DEEPLY curious if there was an overall drop in commit volume.</p></div></td></tr></tbody></table></td></tr><tr id="41622746"><td></td></tr><tr id="41621440"><td><table><tbody><tr><td indent="0"><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_41621440" href="https://news.ycombinator.com/vote?id=41621440&amp;how=up&amp;auth=8cf81027b69de85f738e06c5ecb427408c434fff&amp;goto=item%3Fid%3D41621191#41621440"></a></center></td><td><br><div><p>Dunno, what products do you regularly use?</p><p>I know my hobby stuff is getting better. I generally dont make front ends for my projects, but genai has helped me build widgets for other front ends, and css/js frontends for a lot of my nonsense.</p></div></td></tr></tbody></table></td></tr><tr id="41624285"><td><table><tbody><tr><td indent="0"><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_41624285" href="https://news.ycombinator.com/vote?id=41624285&amp;how=up&amp;auth=f5afe72470a92b38dd0ce60d5ba64eeb7d72b23f&amp;goto=item%3Fid%3D41621191#41624285"></a></center></td><td><br><div><p>Because AI is trained on public available code with no indication of its quality, so it's churning out the already low quality code it finds online.</p></div></td></tr></tbody></table></td></tr><tr id="41623755"><td><table><tbody><tr><td indent="0"><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_41623755" href="https://news.ycombinator.com/vote?id=41623755&amp;how=up&amp;auth=9aaa03264c021a91c7676459965a31100e9ffe65&amp;goto=item%3Fid%3D41621191#41623755"></a></center></td><td><br><div><p>There are two categories of technology. Those which get job done faster and those which get job done easier. Most of nowadays technology belongs to first category.</p></div></td></tr></tbody></table></td></tr><tr id="41621455"><td><table><tbody><tr><td indent="0"><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_41621455" href="https://news.ycombinator.com/vote?id=41621455&amp;how=up&amp;auth=f7399b793b6b4b90b20bfb1e82383db986ff4087&amp;goto=item%3Fid%3D41621191#41621455"></a></center></td><td><br><div><p>The way the question is framed invites a justification: "why it could be improving while not improving".</p><p>I'm sure there are hypotheses. But it's also likely that things are simply not improving.</p></div></td></tr></tbody></table></td></tr><tr id="41621299"><td><table><tbody><tr><td indent="0"><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_41621299" href="https://news.ycombinator.com/vote?id=41621299&amp;how=up&amp;auth=f35de83b147d6233fd713d8c4db6432ec3a569b9&amp;goto=item%3Fid%3D41621191#41621299"></a></center></td><td><br><div><p>I'm a designer=engineer, and I feel like AI has given me super powers. Design has always been easy for me--it was just the incredible grind of coding that made creating my own thing difficult.</p></div></td></tr></tbody></table></td></tr><tr id="41626107"><td><table><tbody><tr><td indent="0"><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_41626107" href="https://news.ycombinator.com/vote?id=41626107&amp;how=up&amp;auth=0911247c0ca6e056e398754631bfbe599aaf19c5&amp;goto=item%3Fid%3D41621191#41626107"></a></center></td><td><br><div><p>Duh. Products are not about making life better. They are about stimulating basal instincts for information and novelty. If a company can do that with a horrible user experience, they will. Although I personally have never used substances or drugs, I think it must be similar to drug addiction. Provide just enough of new technology as fast as possible to keep the users high and addicted.</p></div></td></tr></tbody></table></td></tr><tr id="41626415"><td><table><tbody><tr><td indent="1"><img src="https://news.ycombinator.com/s.gif" height="1" width="40"></td><td><center><a id="up_41626415" href="https://news.ycombinator.com/vote?id=41626415&amp;how=up&amp;auth=aa01cd6fa1819650785f24d3c2bbb5fd641e62a0&amp;goto=item%3Fid%3D41621191#41626415"></a></center></td><td><br><div><p>Nah, drugs are all about the experience. It's only novel the first few times you try a new drug, and sustained use requires the drug to be pleasant!</p><p>In other words, drugs are better than the internet, and we could all learn a thing or two from drugs, to make our products better!</p></div></td></tr></tbody></table></td></tr><tr id="41621358"><td><table><tbody><tr><td indent="0"><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_41621358" href="https://news.ycombinator.com/vote?id=41621358&amp;how=up&amp;auth=e680fe1eb8519e6a4e4069af71e78f4a7f6e2705&amp;goto=item%3Fid%3D41621191#41621358"></a></center></td><td><br><div><p>Better products require better features and better quality. Features are defined by managers, quality is controlled by testing. These haven't benefited from AI as much as coding did.</p></div></td></tr></tbody></table></td></tr><tr id="41621448"><td><table><tbody><tr><td indent="0"><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_41621448" href="https://news.ycombinator.com/vote?id=41621448&amp;how=up&amp;auth=aacf94b4378c94e5937dd3e65ab3536cb07d5406&amp;goto=item%3Fid%3D41621191#41621448"></a></center></td><td><br><div><p>It's partially a product of Amdahl's Law. Coding and related textual activities are only a fraction of the work required for product design, implementation, and maintenance.</p></div></td></tr></tbody></table></td></tr><tr id="41626771"><td></td></tr><tr id="41622739"><td><table><tbody><tr><td indent="0"><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_41622739" href="https://news.ycombinator.com/vote?id=41622739&amp;how=up&amp;auth=8a22904153fbdd66b3ff122cefe62cd77f60fdda&amp;goto=item%3Fid%3D41621191#41622739"></a></center></td><td><br><div><p>Because code quality probably wasn't the bottleneck on product quality, and even if it was then some analogue of Amdahl's law applies.</p></div></td></tr></tbody></table></td></tr><tr id="41629678"><td></td></tr><tr id="41626585"><td></td></tr><tr id="41621425"><td><table><tbody><tr><td indent="0"><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_41621425" href="https://news.ycombinator.com/vote?id=41621425&amp;how=up&amp;auth=ea26c071f9c2370a36da84fda97ddc98cf6a82ef&amp;goto=item%3Fid%3D41621191#41621425"></a></center></td><td><br><div><p>I don't think AI code helpers really understand how to make code which is readable and maintainable, at this stage.</p></div></td></tr></tbody></table></td></tr><tr id="41621423"><td><table><tbody><tr><td indent="0"><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_41621423" href="https://news.ycombinator.com/vote?id=41621423&amp;how=up&amp;auth=c52b5346dd2ce4f7511e604007f81a9ea0ecca82&amp;goto=item%3Fid%3D41621191#41621423"></a></center></td><td><br><div><p>Because it won’t help subpar coders and “100x” types have moved into AI. Meaning, they’re the ones building the tools.</p></div></td></tr></tbody></table></td></tr><tr id="41626318"><td></td></tr><tr id="41626135"><td></td></tr><tr id="41621249"><td></td></tr><tr id="41621282"><td><table><tbody><tr><td indent="1"><img src="https://news.ycombinator.com/s.gif" height="1" width="40"></td><td><center><a id="up_41621282" href="https://news.ycombinator.com/vote?id=41621282&amp;how=up&amp;auth=6e28ed69180661d92672774020f0e42e8019d081&amp;goto=item%3Fid%3D41621191#41621282"></a></center></td><td><br><div><p>This was my first reaction. It hasn't been that long and giant ships can't change course quickly.</p><p>And for much of that year there were a lot of questions around the ownership of AI generated code as well as information security. In fact, most of those questions are still not satisfactorily solved. So I'm not so surprised that we haven't seen massive results "yet"</p></div></td></tr></tbody></table></td></tr><tr id="41628756"><td><table><tbody><tr><td indent="0"><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_41628756" href="https://news.ycombinator.com/vote?id=41628756&amp;how=up&amp;auth=76738332306aa3fe2109d4e24661143d691edbd7&amp;goto=item%3Fid%3D41621191#41628756"></a></center></td><td><br><div><p>High quality products result from the accumulation of fixes and polish. They also add new desirable features in response to user feedback.</p><p>Whether AI is used to write code is irrelevant to a product getting “better”. AI copilots can be used to bootstrap early stage concepts which might be unpolished, or can be used to add polish by writing bug fixes.</p><p>I neither subscribe to the mania around AI, nor do I think it will enshittify products. I believe it is just another tool that we can use.</p></div></td></tr></tbody></table></td></tr><tr id="41621258"><td><table><tbody><tr><td indent="0"><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_41621258" href="https://news.ycombinator.com/vote?id=41621258&amp;how=up&amp;auth=d03c3dca60ef3f19e9880c4e6c952b83be6be9fa&amp;goto=item%3Fid%3D41621191#41621258"></a></center></td><td><br><div><p>Where did that premise come from?</p><p>Copilot mostly helps people code faster, or with less knowledge required. I'd expect output quality to go down, not up.</p><p>And it's like anything in capitalism. Companies could choose higher quality, but instead they do whatever gives the highest profit. which is usually adequate quality at low cost.</p></div></td></tr></tbody></table></td></tr><tr id="41628473"><td><table><tbody><tr><td indent="0"><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_41628473" href="https://news.ycombinator.com/vote?id=41628473&amp;how=up&amp;auth=2295224c376ba740e17f26862d206a26460baef5&amp;goto=item%3Fid%3D41621191#41628473"></a></center></td><td><br><div><p>The key is that <i>if</i>. What if it isn't, yet? What if right now the AI is in a phase where it's still learning and doesn't produce good stuff yet?</p><p>Besides, products have been getting worse for a while. Enshittification is a potent force, and even if AI was axiomatically helping people code faster and better, enshittification might still lead them to add in annoyances, privacy risks, et cetera.</p></div></td></tr></tbody></table></td></tr><tr id="41626566"><td><table><tbody><tr><td indent="0"><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_41626566" href="https://news.ycombinator.com/vote?id=41626566&amp;how=up&amp;auth=49a84c93f7f37e0414500e85a37747a88c4b8218&amp;goto=item%3Fid%3D41621191#41626566"></a></center></td><td><br><div><p>Better programming, task to task, does not result in better applications.</p><p>For a simple example, consider a would be program that takes 100 tasks of 16 hours each to build a program with a quality of 75%. With AI, those tasks can take an average of 12 hours each, meaning the software can be delivered faster. Unless someone purposefully invests the saved time into improving the program, you'll end up with the same 75% quality program faster.</p><p>Now what if AI makes the code slightly worse, leading the quality to drop to 70%, but some of the savings are used to improve quality, bringing it back up to 75%? Same outcome of the product not being any better to the end user.</p><p>Even if the code is higher quality, how much of that 25% of missing quality is the result of bad code verses bad designs or a mismatch between what customer wants and what those designing the project think the customer wants? Even a perfect AI that solves all bugs won't improve that.</p><p>In short, programming better can mean many different things, some of which might translate to a better or worse product, but with no consistency.</p></div></td></tr></tbody></table></td></tr><tr id="41621291"><td></td></tr><tr id="41625475"><td><table><tbody><tr><td indent="0"><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_41625475" href="https://news.ycombinator.com/vote?id=41625475&amp;how=up&amp;auth=879a46d18bbef2e65700a935dedffa2813a47288&amp;goto=item%3Fid%3D41621191#41625475"></a></center></td><td><br><div><p>&gt; If AI is helping people code a lot faster and better</p><p>You may as well ask why the advent of StackOverflow didn't massively increase app quality, it's the same target audience.</p></div></td></tr></tbody></table></td></tr><tr id="41622317"><td></td></tr><tr id="41622263"><td></td></tr><tr id="41621334"><td><table><tbody><tr><td indent="0"><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_41621334" href="https://news.ycombinator.com/vote?id=41621334&amp;how=up&amp;auth=5a4bd9e8305918b662f0b39c10a9d2cb70a28fe3&amp;goto=item%3Fid%3D41621191#41621334"></a></center></td><td><br><div><p>Digital distribution and cloud apps lowered the cost to correct mistakes and therefore lowered the barrier to release.</p><p>No longer are developers bound by physical media, or have to force clients to troubleshoot, manually download updates on their website and install them.</p><p>... and as others said, LLMs impact is greater on junior developers, and at that, more on speed than quality. For experienced developers, the impact is greater on speed.</p><p>I have no data, only sense to make.</p></div></td></tr></tbody></table></td></tr><tr id="41629775"><td><table><tbody><tr><td indent="0"><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_41629775" href="https://news.ycombinator.com/vote?id=41629775&amp;how=up&amp;auth=346f2c13b884509fcec05fc4a2478a50a4d948ea&amp;goto=item%3Fid%3D41621191#41629775"></a></center></td><td><br><div><p>How many times are these naive questions going to resurface?</p><p>Of course this all depends on what you mean by "better", or for whom the product is better.</p><p>AI, like every technical advance in history, will be deemed "better" if fewer people make more money from it.</p><p>This has nothing to do with you, mister insignificant user...</p></div></td></tr></tbody></table></td></tr><tr id="41621559"><td></td></tr><tr id="41626143"><td></td></tr><tr id="41626537"><td><table><tbody><tr><td indent="0"><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_41626537" href="https://news.ycombinator.com/vote?id=41626537&amp;how=up&amp;auth=d8ccd7536618d9a8d3a629b2f871fea555a043e0&amp;goto=item%3Fid%3D41621191#41626537"></a></center></td><td><br><div><p>I believe it increases the speed of the <i>coding</i>, but not the quality. It doesn't do your QA for you. It doesn't do your UX for you. And if you're a code monkey assigned to implement a feature you know will drag the product down, well, you'll get that out the door faster. AI won't force the marketing people to make good decisions, or create sane deadlines, and so on.</p></div></td></tr></tbody></table></td></tr><tr id="41621427"><td><table><tbody><tr><td indent="0"><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_41621427" href="https://news.ycombinator.com/vote?id=41621427&amp;how=up&amp;auth=06f97ac38ec930bbb532e8da1e3f9c274b77422a&amp;goto=item%3Fid%3D41621191#41621427"></a></center></td><td><br><div><p>It's complex - an essay in and of itself if we're to respond properly, but I'll try to keep things brief here.</p><p>First, let's address the tooling side. While the current crop of "code completion tools" built out of or around LLMs are quite capable in their own right, they're not exactly "free thinkers" like we can be. Rather, their output is limited by a combination of training data, the model itself, and - increasingly - the user's ability to put their ideas into a prompt that can generate the desired output consistently. So there's already a huge hurdle just on the tooling side to overcome before we can begin "improving", one tied just as much to the capabilities of the product as the capabilities of the end user. I would argue that this is the most immediate hurdle to cross if we want to see meaningful improvements to code as a whole.</p><p>In addition to that immediate hurdle, there's three more issues on the tooling front:</p><p>* The existing training data is largely bad, bloated, or insecure code samples (generally from publicly-available social media and repositories), because code security and efficiency are only relatively recent prerogatives of large development companies or outfits as they seek to dodge lawsuits (security) and increase margins (efficiency)</p><p>* LLMs aren't very good at teaching a user how to think better about a problem, only making them better at phrasing their prompt to get closer to a possible solution</p><p>* LLMs are stuck in a predictive framework that mandates an answer for the customer, as opposed to a human who is able to say "I don't know" and going off to learn more about that thing they're stuck on.</p><p>Ultimately, the tooling is helping novice or entry-level developers and hobbyists write better code, but only because the models were trained on code from more senior or professional developers that was also shared publicly. Senior developers and above may find utility in writing faster code with LLMs, but aren't nearly as likely to write better code as a result of the tooling, at least from my subjective reasoning.</p><p>Now let's switch to the business side of things, which I already touched on above. Businesses haven't been interested in secure or efficient code until very recently, as we began bumping up against the limits of physical hardware in x86-64 land and lawsuits for failures became more of an existential threat. This means a lot of the code from public samples fits the "done is better than good" mantra of modern business practices, rather than being an improvement to prior releases; even if a business has taken the time to create more secure or efficient code, they likely haven't shared it as it's a core part of their competitive advantage or product line. This will take years, maybe a decade before the LLM training sets have enough "superior" data to outscore the "inferior" training set data, during which time the status quo - barring a literal revolution in computing - is likely to remain.</p><p>Admittedly all of this is my subjective POV from infrastructure-world, and could be way off base; YMMV, buyer beware, caveat emptor, etc.</p></div></td></tr></tbody></table></td></tr><tr id="41621409"><td><table><tbody><tr><td indent="0"><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_41621409" href="https://news.ycombinator.com/vote?id=41621409&amp;how=up&amp;auth=1bc7c804ebb198f2c994e248be1fe28cd4c62a68&amp;goto=item%3Fid%3D41621191#41621409"></a></center></td><td><br><div><p>You're using the wrong products!</p><p>1. Look for products that don't have (c)opyright. Any product still using that or licenses is going to evolve too slow and go extinct.</p><p>2. Look for products built on revolutionary simpler stacks like PPS.</p><p>I thought this was going to be an essay and not just a Tweet, so I did record a long winded response, which I think contains a lot of relevant info: <a href="https://news.pub/?try=https://www.youtube.com/embed/KhDvFNefvuU?si=xWWtKewSZe3V1j7i" rel="nofollow">https://news.pub/?try=https://www.youtube.com/embed/KhDvFNef...</a></p></div></td></tr></tbody></table></td></tr><tr id="41621349"><td><table><tbody><tr><td indent="0"><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_41621349" href="https://news.ycombinator.com/vote?id=41621349&amp;how=up&amp;auth=6727db6ccbdd5f926ed49e34bf64640dc0e55682&amp;goto=item%3Fid%3D41621191#41621349"></a></center></td><td><br><div><p>Maybe things that weren't being built (available capacity to develop) is increasing, thereby lifting up the floor of things that never get built.</p><p>Further, non-coders being able to become equivalent to a junior developer is a huge leap.</p><p>What active developers do with AI remains to be seen. It really could 20x the average developer, but it doesn't seem like a huge chunk of developers are really using AI in a way that it's the rage on the developer level broadly.</p><p>Maybe that's why Cursor going "viral" on youtube seems different when it was known to some, and not others.</p></div></td></tr></tbody></table></td></tr><tr id="41621460"><td></td></tr><tr id="41622475"><td><table><tbody><tr><td indent="0"><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_41622475" href="https://news.ycombinator.com/vote?id=41622475&amp;how=up&amp;auth=0965f99a0fcb752a6e8862ee2612306f247e5f1a&amp;goto=item%3Fid%3D41621191#41622475"></a></center></td><td><br><div><p>&gt; If AI is helping people code better</p><p>I don't think it is?</p><p>30+ years of experience here and I haven't seen any AI coding examples that makes me want to use AI for coding.</p><p>It might happen one day but so far nope.</p></div></td></tr></tbody></table></td></tr><tr id="41630671"><td><table><tbody><tr><td indent="0"><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_41630671" href="https://news.ycombinator.com/vote?id=41630671&amp;how=up&amp;auth=350213457ddbf4f9236775b49e25634109202770&amp;goto=item%3Fid%3D41621191#41630671"></a></center></td><td><br><div><p>Based on my experience, at the present moment in time, I think you should be expecting more code (groundbreaking improvements in productivity), but not necessarily significantly better code. But certainly not worse code. Current generation AIs are writing tactical code absolutely brilliantly (often better than my own code), but often making very odd strategic decisions (functionally decomposing code in odd ways, for example).</p><p>But, the rate of change in this area is breathtaking. I reasonably expect my AI to improve in the coming months, or even weeks. And I find it difficult to keep up with which AIs are best for generating code at any given moment. There may be AIs that are good at reviewing multi-million-line code bases for security flaws. But I am not currently using one at the present time.</p><p>What I do know: my AI coding partner this year is writing code that is more accurate and more stylish than any AIs were producing this time last year. The code that's being produced is often strategically brilliant -- elegant, concise, only very occasionally using hard-coded constants instead of including the correct headers, and almost completely absent of "hallucinations". And I'm using it to regularly generate code in three different languages (C++ for the app server, typescript for the web client, java for the Android client application).</p><p>I've frequently found myself adopting coding conventions that my AI has shown me. I particularly like</p><pre><code>    namespace fs = std::filesystem;
</code></pre><p>And the solution it came up with for writing a std:filebuf implementation stills leaves me speechless. I've done that a few times over my career, and the solution the AI uses is infinitely superior to anything I've ever written -- not something I've EVER seen, but clearly the horrible, never documented way the original authors of the iostream libraries MEANT people to do it, which provides substantial advantages over the way I've been doing it. And absolutely nowhere to be found in the first 30 page of google searches, or among the strangely variously broken and obsolete fragments of code on StackExchange.</p><p>But my current AI often falls short when it comes to strategic thinking. Functional decomposition is often odd. I often have to refactor code that my AI generates -- sometimes by coaching it through refactoring, and sometimes doing it myself when I move the generated code into production code. But that may change next week. Who knows?</p><p>Have I used it for debugging existing code? A couple of times. I'm not currently seeing a huge productivity boost in this area.</p><p>Today, I coached it to write me a bash shell script to generate a graph of a key development metric using gnuplot. Bash: as a former Windows programmer, bash still terrifies me. Gnuplot: a documentation set that could be called unforgiveable if you were feeling particularly generous. Took me about 20 minutes. "Change the font of the title, please". "Take input from this program, which produces a column of ISO 8601 dates, and an integer value". "Rotate the date labels 90 degrees anti-clockwise" (It mistakenly rotated them clockwise. The only flaw in an otherwise fantastic performance). Etc. It took me about 20 minutes to do what would have taken me a couple of hours. I wouldn't have done it if I didn't have an AI at my disposal.</p><p>Context: Using Claude 3.5, 40 years of very senior Windows development experience, but only about 3 years of Linux development experience.</p></div></td></tr></tbody></table></td></tr><tr id="41621443"><td></td></tr><tr id="41635851"><td></td></tr></tbody></table>
